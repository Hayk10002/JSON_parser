Syntax specification of Json used in this project
This is pseudocode


// Type = json_parse_types::Json
// InputType = stringstream
// ReturnType = Json 
// ErrorType = ...
json = seq(ws value ws)

// Type = json_parse_types::Value
// InputType = stringstream
// ReturnType = Json 
// ErrorType = ...
value = or(object array string number_int number_float boolean null)

// Type = json_parse_types::Object
// InputType = stringstream
// ReturnType = Json::ObjectType 
// ErrorType = ...
object = seq(char('{') or(ws cycle(seq(ws string ws char(':') json) char(','))) char('}'))

// Type = json_parse_types::Array
// InputType = stringstream
// ReturnType = Json::ArrayType
// ErrorType = ...
array = seq(char('[') or(ws cycle(json char(','))) char(']'))

// Type = json_parse_types::String
// InputType = stringstream
// ReturnType = Json::StringType
// ErrorType = ...
string = seq(char('"') cycle(or(unicode_char('0020' . '10FFFF' - '"' - '\') seq(char('\') escape))) char('"'))

// Type = json_parse_types::NumberInt
// InputType = stringstream
// ReturnType = Json::IntType
// ErrorType = ...
number_int = seq(or(nothing char('-')) or(digit seq(onenine digits)))

// Type = json_parse_types::NumberFloat
// InputType = stringstream
// ReturnType = Json::FloatType
// ErrorType = ...
number_float = seq(number_int or(fraction exponent seq(fraction exponent)))

// Type = json_parse_types::Bool
// InputType = stringstream
// ReturnType = Json::BooleanType
// ErrorType = ...
boolean = or(str("true") str("false"))

// Type = json_parse_types::Null
// InputType = stringstream
// ReturnType = Json::NullType
// ErrorType = ...
null = str("null")

// Type = json_parse_types::Whitespace
// InputType = stringstream
// ReturnType = Json::NullType
// ErrorType = ...
ws = cycle(char('0020' + '000A' + '000D' + '0009'))

// Type = json_parse_types::Escape
// InputType = stringstream
// ReturnType = Json::StringType
// ErrorType = ...
escape = or(char('"' + '\' + '/' + 'b' + 'f' + 'n' + 'r' + 't') seq(char('u') hex hex hex hex))

// Type = json_parse_types::Hex
// InputType = stringstream
// ReturnType = Json::CharType (value can be from 0 to 15)
// ErrorType = 
hex = char('0' . '9' + 'A' . 'F' + 'a' . 'f')

// Type = json_parse_types::Digit
// InputType = stringstream
// ReturnType = Json::CharType (value can be from 0 to 9)
// ErrorType = ...
digit = char('0' . '9')

// Type = json_parse_types::Fraction
// InputType = stringstream
// ReturnType = Json::FloatType
// ErrorType = ...
fraction = seq(char('.') digits)

// Type = json_parse_types::Exponent
// InputType = stringstream
// ReturnType = Json::IntType
// ErrorType = ...
exponent = seq(char('e' + 'E') sign digits)

// Type = json_parse_types::OneNine
// InputType = stringstream
// ReturnType = Json::CharType (value can be from 1 to 9)
// ErrorType = ...
onenine = char('1' . '9')

// Type = json_parse_types::Sign
// InputType = stringstream
// ReturnType = Json::BooleanType 
// ErrorType = ...
sign = or(nothing char('-' + '+'))

// Type = json_parse_types::Digits
// InputType = stringstream
// ReturnType = Json::ArrayTypeT<Json::CharType>
// ErrorType = ...
digits = cycle(digit)


char(accepted) -> char
str(accepted) -> string
unicode_char(accepted) -> utf8_string
seq -> tuple
or -> variant
cycle(elem separator) -> vector (nothing or elem or elem+separator+elem or elem+separator+elem+separator+elem or ....)
